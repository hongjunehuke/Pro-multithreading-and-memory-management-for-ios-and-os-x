# ARC 이전의 삶

ARC는 프로그래머를 대신해 컴파일러가 메로리를 관리하게 함으로써 성능 향상에 도움을 줍니다.

ARC가 등장하기 이전, 개발자는 직접 retain과 release를 삽입하여 메모리를 관리했습니다.
인스턴스를 참조하고 있는 포인터 개수가 0이 되어야 메모리에서 해제됩니다.

이번 장에서는 메모리 관리에 대한 개념과 alloc, dealloc 그리고 autorelease 같은 메모리 관리 함수와 함수 구현부를 살펴봅시다.

## 레퍼런스를 계산하는 메모리 관리 방식의 개요

Objective-C에서 "메모리 관리"는 "레퍼런스 카운팅"과 동일한 의미입니다.

메모리가 필요로 할 때 메모리 영역에 프로그래머가 공간을 할당하고, 더 이상 필요하지 않다면 메모리를 해제하는 것을 메모리 관리하고 합니다.
이때 필요하지 않은 메모리를 해제하지 않으면 메모리가 누수됩니다.

Objective-C에서 객체를 관리하는 방법은 네 가지로 나뉩니다.

1. 객체를 생성하고 그에 대한 소유권을 갖습니다.
2. 객체의 소유권을 획득합니다.
3. 객체의 소유권을 내줍니다.
4. 객체를 버립니다.

객체를 생성하고 그에 대한 소유권을 A가 가질 경우, 해당 객체의 카운터는 1이 됩니다.
이후 B에서 객체의 소유권을 획득하면 객체의 카운터는 2가 됩니다.
소유권을 가진 A가 객체에 대한 소유권을 포기하면 객체의 카운터는 1이 되고, B까지 객체에 대한 소유권을 포기하면 카운터가 0이 되며 객체가 소멸됩니다.

아래 그림과 같이 Objective-C에서는 레퍼런스 카운팅으로 객체들을 관리합니다.

![image](https://github.com/hongjunehuke/Pro-multithreading-and-memory-management-for-ios-and-os-x/assets/83629193/59eaf1d9-f754-47ba-92b8-423a9b3597a6)

추가적으로 레퍼런스 카운터는 각 객체의 헤더에 존재합니다.

개발자는 각 객체들의 레퍼런스 카운터 값 자체를 알 필요까지 없습니다.
하지만 아래의 네 가지 레퍼런스 카운팅 규칙은 알고 있어야 합니다.

- 레퍼런스 카운팅 규칙
1. 생성하는 모든 객체는 동시에 소유권을 갖습니다.
2. "retain"을 사용하여 객체의 소유권을 획득할 수 있습니다.
3. 더 이상 객체가 필요하지 않으면 소유하고 있는 객체의 소유권을 내줘야 합니다.
4. 소유하고 있지 않는 객체의 소유권은 내주면 안됩니다.

위에서 Objective-C에서 객체를 관리하는 방법 네 가지를 실행시키는 함수를 소개하려 합니다.

- 객체를 관리하는 함수
1. 객체를 생성 & 소유권 획득 -> alloc/new/copy/mutableCopy 함수
2. 소유권 획득 -> retain 함수
3. 소유권 포기 -> release 함수
4. 객체 소멸 -> dealloc 함수

하지만 위에서 소개한 함수들을 Objective-C에서 제공하지 않습니다.
Coca Framework 내부의 Foundation Framework에서 제공하는 NSObject 클래스에서 제공하는 함수들입니다.

지금부터 앞에서 소개한 네 가지 레퍼런스 카운팅 규칙을 살펴봅시다.

**1. 생성하는 모든 객체는 동시에 소유권을 갖습니다.**

NSObject 클래스에서 제공하는 alloc, new, copy, mutableCopy 함수를 사용하여 객체를 생성하는 동시에 해당 객체의 소유권을 가집니다.

코드를 통해 함수를 사용하는 방법을 살펴봅시다.

아래 코드는 Swift 코드가 아닌 Objective-C 코드지만 어떤 동작을 하는지 정도는 알 수 있는 코드입니다.

```Objective-C
// 객체 생성 및 소유권 획득
id obj = [[NSObject alloc] init]; // 이제 객체의 소유권을 가집니다.
```

alloc 함수를 호출하여 객체를 생성함과 동시에 객체의 소유권도 가집니다.
이때 obj 변수는 생성된 객체의 포인터를 갖습니다.

```Objective-C
// 객체 생성 및 소유권 획득
id obj = [NSObject new]; // 이제 객체의 소유권을 가집니다.
```

[NSObject new]와 [[NSObject alloc] init]은 같은 기능을 수행합니다.

copy 함수는 객체의 복사본을 생성하고, mutableCopy 함수는 객체의 변경 가능한(mutable) 복사본을 생성합니다.
이때 copy, mutableCopy 함수 모두 alloc과 new 함수와 동일하게 객체 생성과 함께 객체의 소유권까지 가집니다.

**2. "retain"을 이용해 객체의 소유권을 획득합니다.**

객체의 소유권을 획득할 때 retain 함수를 사용할 수 있습니다.

소유권은 Reference count로 객체에 대한 참조를 뜻합니다.

위에서 살펴본 alloc/new/copy/mutableCopy 함수는 retain 함수 없이 객체를 생성함과 동시에 자동으로 소유권을 획득하게 됩니다.

하지만 자동으로 소유권을 획득하지 못하여, 직접 retain 함수를 호출해 객체의 소유권을 획득해야 하는 경우도 존재합니다.

alloc/new/copy/mutableCopy 함수 외에도 객체를 반환하는 함수가 존재할 수 있습니다.
하지만 이때는 객체를 생성한 것도 아니고 객체의 소유권을 획득한 상태도 아닙니다.

이때 retain 함수를 사용해서 객체에 대한 소유권을 얻을 수 있습니다.

아래 코드로 살펴봅시다.

```Objective-C
// alloc/new/copy/mutableCopy 이외에 함수가 객체를 반환하는 경우입니다. (직접 객체를 생성하거나 소유권을 획득하지 않고 얻은 객체입니다.)
id obj = [NSMutableArray array]; 
// 이렇게 얻은 객체는 존재하지만, 소유권을 갖지 않습니다.
[obj retain];
// retain 함수를 통해 소유권을 얻었습니다.
```

retain 함수를 호출한 이후에는 alloc/new/copy/mutableCopy 함수와 같이 객체의 소유권을 획득하게 됩니다.

Swift에서는 변수를 구현하는것만으로 객체의 소유권을 얻지만, 메모리 관리를 개발자가 직접했던 ARC 사용 이전에는 소유권에 대한 개념이 강조되었던것 같습니다.

**3. 더 이상 객체가 필요하지 않으면 소유하고 있는 객체의 소유권을 내줘야 합니다.**

객체를 소유하고 있지만 더 이상 객체가 필요하지 않다면 release 함수를 호출하여 객체의 소유권을 직접 내줘야 합니다.

아래 코드로 살펴봅시다.















